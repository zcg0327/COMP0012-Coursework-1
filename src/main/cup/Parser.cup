import java_cup.runtime.*;

parser code {:
  private Lexer lexer;

  public Parser(Lexer lexer) {
    super(lexer);
    this.lexer = lexer;
  }

  public void syntax_error(Symbol current_token) {
    report_error(
        "Syntax error at line " + (current_token.left+1) + ", column "
        + current_token.right + ". ", null
    );
  }

:};

scan with {: return lexer.next_token(); :};


/* Terminals */

// Keywords, Identifiers
terminal    IDENTIFIER,                             // id
            SECURITY_LOW,                           // Low security
            SECURITY_HIGH,                          // High security
            CHAR,                                   // char
            BOOL,                                   // bool
            INT,                                    // int
            RAT,                                    // rat
            FLOAT,                                  // float
            SEQ,                                    // seq
            TOP,                                    // top
            LEN,                                    // len
            IN,                                     // in
            TDEF,                                   // Type definition
            ALIAS,                                  // Type alias
            FDEF,                                   // Function definition
            MAIN,                                   // Special main method
            READ,                                   // Input
            PRINT,                                  // Output
            IF,                                     // If-begin
            FI,                                     // If-end
            THEN,
            ELSE,
            LOOP,                                   // Loop-begin
            POOL,                                   // Loop-end
            BREAK,
            RETURN,
            TRUE,                                   // T
            FALSE                                   // F
            ;

// Literals
terminal    CHAR_LITERAL,                           // 'x'
            INT_LITERAL,                            // 123
            RAT_LITERAL,                            // 1/2
            FLOAT_LITERAL,                          // 1.234
            STRING_LITERAL                          // "hello, world"
            ;

// Separators, Grouping Operators, Terminators
terminal    LPAREN,                                 // (
            RPAREN,                                 // )
            LANGLE,                                 // <        // N.B. also the less than operator
            RANGLE,                                 // >
            LBRACE,                                 // {
            RBRACE,                                 // }
            LBRACKET,                               // [
            RBRACKET,                               // ]
            SEMICOLON,                              // ;
            COMMA                                   // ,
            ;

// Operators
terminal    ASSIGN,                                 // :=
            COLON,                                  // :
            PLUS,                                   // +
            MINUS,                                  // -
            DIV,                                    // /
            MULT,                                   // *
            EXP,                                    // ^
            NOT,                                    // !
            AND,                                    // &&
            OR,                                     // ||
            CONCAT,                                 // ::
            LESS_EQ,                                // <=
            EQ,                                     // =
            NEQ,                                    // !=
            DOT                                     // .
            ;

terminal    BADCHAR;

/* FIXME TODO

/* Non-terminals */

// TODO
// nonterminal zsec_program;


/* Production Rules */

// NB: Minimum required is a main function declaration, with optional
// declaration statements before and after.
zsec_program ::= top_level_statement_list main_function_declaration_statement top_level_statement_list;

top_level_statement_list  ::= top_level_statement
                          |   top_level_statement top_level_statement_list
                          |   /* empty */
                          ;

main_function_declaration_statement ::= MAIN LBRACE statement_list RBRACE SEMICOLON;

top_level_statement ::= variable_declaration_statement
                    |   datatype_declaration_statement
                    |   function_declaration_statement
                    ;

variable_declaration_statement  ::= variable_declaration SEMICOLON
                                |   variable_declaration ASSIGN expression_list SEMICOLON
                                ;

datatype_declaration_statement  ::= datatype_declaration SEMICOLON;

function_declaration_statement  ::= function_declaration SEMICOLON;

variable_declaration  ::= IDENTIFIER COLON type_expression;

expression_list ::= expression
                |   expression COMMA expression_list
                ;

datatype_declaration  ::= TDEF IDENTIFIER LBRACE variable_declaration_list RBRACE;

function_declaration  ::= FDEF IDENTIFIER LPAREN formal_parameter_list RPAREN LBRACE statement_list RBRACE
                      |   FDEF IDENTIFIER LPAREN formal_parameter_list RPAREN LBRACE statement_list RBRACE COLON type_expression
                      ;

type_expression ::= primitive_type_expression
                |   sequence_type_expression
                |   IDENTIFIER
                ;

// TODO: CONCAT
// OPERATOR PRECEDENCE (HIGH -> LOW)
// ()                  // Parentheses
// f()                 // Function call
// x[]                 // Slicing
// x.y                 // Field access (left assoc.)
// ^                   // Exponentiation (right assoc.)
// + - !               // Unary plus, unary minus, unary not (right assoc.)
// * /                 // Binary mult, div (left assoc.)
// + -                 // Binary plus, binary minus (left assoc.)
// < <= in             // Less, less than, in (no assoc.)
// = !=                // Equality, inequality (no assoc.)
// &&                  // And (left assoc.)
// ||                  // Or (left assoc.)
expression  ::= or_part;

or_part ::= or_expression OR and_part
        |   and_part
        ;

and_part  ::= equality_part EQ equality_part
          |   equality_part NEQ equality_part
          |   equality_part
          ;

equality_part ::= comparison_membership_part LANGLE comparison_membership_part
              |   comparison_membership_part LESS_EQ comparison_membership_part
              |   comparison_membership_part IN comparison_membership_part
              |   comparison_membership_part
              ;

comparison_membership_part  ::= comparison_membership_part PLUS add_part
                            |   comparison_membership_part MINUS add_part
                            |   add_part
                            ;

add_part  ::= add_part MULT mult_part
          |   add_part DIV mult_part
          |   mult_part
          ;

mult_part ::= unary;

unary ::= PLUS unary
      |   MINUS unary
      |   NOT unary
      |   exp_part
      ;

exp_part  ::= field_access_part EXP exp_part
          |   field_access_part
          ;

field_access_part ::= field_access_part DOT IDENTIFIER
                  |   group
                  ;

group ::= value
      |   value LBRACKET expression RBRACKET
      |   value LPAREN expression_list RPAREN
      |   LPAREN expression LPAREN
      ;

value ::= IDENTIFIER
      |   literal
      ;

literal ::= INT_LITERAL
        |   FLOAT_LITERAL
        |   RAT_LITERAL
        |   CHAR_LITERAL
        |   STRING_LITERAL
        |   bool_literal
        |   list_literal
        ;

bool_literal  ::= TRUE
              |   FALSE
              ;

list_literal  ::= empty_list_literal
              |   LBRACKET expression_list RBRACKET
              ;

empty_list_literal  ::= LBRACKET RBRACKET;

variable_declaration_list ::= variable_declaration
                          |   variable_declaration COMMA variable_declaration_list
                          ;

formal_parameter_list ::= variable_declaration_list
                      |   /* empty */
                      ;

statement_list  ::= statement
                |   statement statement_list
                ;

primitive_type_expression ::= primitive_type security_label;

sequence_type_expression  ::= SEQ LANGLE sequence_type RANGLE;

statement ::= variable_declaration_statement
          |   datatype_declaration_statement
          |   assignment_statement
          |   input_statement
          |   print_statement
          |   function_call_statement
          |   if_statement
          |   loop_statement
          |   break_statement
          |   return_statement
          ;

primitive_type  ::= BOOL
                |   INT
                |   RAT
                |   FLOAT
                |   CHAR
                ;

security_label  ::= SECURITY_LOW
                |   SECURITY_HIGH
                ;

sequence_type   ::= primitive_type_expression
                |   TOP security_label
                |   IDENTIFIER
                ;

assignment_statement  ::= IDENTIFIER ASSIGN expression COLON;

input_statement ::= READ IDENTIFIER COLON;

print_statement ::= expression COLON;

function_call_statement ::= IDENTIFIER LPAREN expression_list RPAREN COLON;

// TODO
//if_statement  ::=

loop_statement  ::= LOOP statement_list POOL COLON;

break_statement ::= BREAK COLON
                |   BREAK INT_LITERAL COLON
                ;

return_statement  ::= RETURN expression COLON;

*/
